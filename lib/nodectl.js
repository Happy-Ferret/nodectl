// Generated by CoffeeScript 1.6.3
var NC, NODECTL, ROOTCTL, STDERR, STDOUT, cluster, coffee, exec, fs, jade, markup, mkdirp, moment, path, spawn, sqwish, stylus, uglify, util, _base, _ref;

fs = require('fs');

path = require('path');

util = require('util');

cluster = require('cluster');

_ref = require('child_process'), exec = _ref.exec, spawn = _ref.spawn;

mkdirp = require('mkdirp');

moment = require('moment');

coffee = require('coffee-script');

stylus = require('stylus');

jade = require('jade');

uglify = require('uglify-js');

sqwish = require('sqwish');

markup = require('html-minifier');

(_base = process.env).NODECTL || (_base.NODECTL = 'master');

NC = {};

STDOUT = fs.createWriteStream('/dev/null');

STDERR = fs.createWriteStream('/dev/null');

ROOTCTL = path.join(path.dirname(process.mainModule.filename), '..');

NODECTL = require(path.join(ROOTCTL, 'package.json'));

(function() {
  var dir, e, i, j, trace, _i, _j, _len, _len1, _ref1, _ref2;
  try {
    _ref1 = process.cwd().split(path.sep);
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      dir = _ref1[i];
      trace = '';
      _ref2 = Array(i);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        j = _ref2[_j];
        trace += ".." + path.sep;
      }
      if (fs.existsSync(path.resolve(trace, 'package.json'))) {
        NC.ROOTDIR = path.resolve(trace);
      }
    }
    if (!NC.ROOTDIR) {
      throw new Error('cannot find package.json');
    }
  } catch (_error) {
    e = _error;
    console.error("\x1b[31mProjectError: " + e.message + "\x1b[0m");
    process.exit(1);
  }
  NC.PKGINFO = {
    NODECTL: (function() {
      try {
        return require(path.join(NC.ROOTDIR, '.nodectl.json'));
      } catch (_error) {
        e = _error;
        return {};
      }
    })(),
    PROJECT: (function() {
      try {
        return require(path.join(NC.ROOTDIR, 'package.json'));
      } catch (_error) {
        e = _error;
        return {};
      }
    })()
  };
  NC.DEFAULT = function(key, val) {
    return NC.PKGINFO.NODECTL[key] || NC.PKGINFO.PROJECT[key] || val;
  };
  NC.SYMBOLS = 'start';
  NC.ACTIONS = {
    start: true,
    stop: false,
    restart: false,
    status: false,
    debug: false,
    version: false,
    help: false
  };
  NC.OPTIONS = {
    port: NC.DEFAULT('port', 3000),
    env: NC.DEFAULT('env', 'development'),
    cluster: NC.DEFAULT('cluster', (require('os')).cpus().length),
    delay: NC.DEFAULT('delay', 250),
    exec: NC.DEFAULT('exec', ''),
    setenv: NC.DEFAULT('setenv', {}),
    log: NC.DEFAULT('log', ''),
    stdout: NC.DEFAULT('stdout', ''),
    stderr: NC.DEFAULT('stderr', ''),
    assets: NC.DEFAULT('assets', ''),
    output: NC.DEFAULT('output', ''),
    minify: NC.DEFAULT('minify', false),
    daemon: NC.DEFAULT('daemon', false),
    watch: NC.DEFAULT('watch', false),
    nocolor: NC.DEFAULT('nocolor', false)
  };
  NC.PROJECT = {
    name: NC.DEFAULT('name', false),
    main: NC.DEFAULT('main', false),
    version: NC.DEFAULT('version', false),
    running: path.join(NC.ROOTDIR, '.nodectl.run')
  };
  NC.PROCESS = {
    id: "" + NC.PROJECT.name + "/" + NC.PROJECT.version,
    pid: null,
    wid: [],
    xid: null
  };
  NC.DELETES = function() {
    NC.IMPORTS();
    try {
      process.kill(NC.PROCESS.pid, 'SIGINT');
      console.warn("" + NC.PROCESS.id + " stopped.");
    } catch (_error) {
      e = _error;
      console.error("ProcessError: " + e.message);
    }
    try {
      process.kill(NC.PROCESS.xid, 'SIGINT');
      return console.warn("" + NC.PROCESS.id + " exec process stopped.");
    } catch (_error) {
      e = _error;
      return console.warn("" + NC.PROCESS.id + " exec process already stopped.");
    } finally {
      if (fs.existsSync(NC.PROJECT.running)) {
        fs.unlinkSync(NC.PROJECT.running);
      }
    }
  };
  NC.EXPORTS = function() {
    try {
      if (NC.ACTIONS.debug) {
        return fs.writeFileSync(NC.PROJECT.running, JSON.stringify(NC, null, '  '));
      } else {
        return fs.writeFileSync(NC.PROJECT.running, JSON.stringify(NC));
      }
    } catch (_error) {
      e = _error;
      return console.error(e);
    } finally {
      return NC;
    }
  };
  NC.IMPORTS = function() {
    var json, k, v, _results;
    try {
      if (fs.existsSync(NC.PROJECT.running)) {
        json = JSON.parse(fs.readFileSync(NC.PROJECT.running, 'utf-8'));
        _results = [];
        for (k in json) {
          v = json[k];
          _results.push(NC[k] = v);
        }
        return _results;
      }
    } catch (_error) {
      e = _error;
      return console.error(e);
    } finally {
      return NC;
    }
  };
  if (fs.existsSync(NC.PROJECT.running)) {
    return NC.IMPORTS();
  }
})();

(function() {
  var ARGS, arg, e, envs, key, next, _i, _len, _ref1;
  ARGS = [].concat(process.argv);
  ARGS.splice(0, 2);
  try {
    while (arg = ARGS.shift()) {
      if ('-' !== arg.substr(0, 1)) {
        switch (arg) {
          case 'start':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = true;
            NC.ACTIONS.stop = false;
            NC.ACTIONS.restart = false;
            NC.ACTIONS.status = false;
            break;
          case 'stop':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = false;
            NC.ACTIONS.stop = true;
            NC.ACTIONS.restart = false;
            NC.ACTIONS.status = false;
            break;
          case 'restart':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = false;
            NC.ACTIONS.stop = false;
            NC.ACTIONS.restart = true;
            NC.ACTIONS.status = false;
            break;
          case 'status':
            NC.SYMBOLS = arg;
            NC.ACTIONS.start = false;
            NC.ACTIONS.stop = false;
            NC.ACTIONS.restart = false;
            NC.ACTIONS.status = true;
            break;
          case 'version':
            NC.SYMBOLS = arg;
            NC.ACTIONS.version = true;
            break;
          case 'help':
            NC.SYMBOLS = arg;
            NC.ACTIONS.help = true;
            break;
          default:
            NC.PROJECT.main = arg;
            if (!fs.existsSync(NC.PROJECT.main)) {
              throw new Error("unrecognized action: " + arg);
            }
        }
      } else {
        switch (arg) {
          case '-p':
          case '-port':
          case '--port':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.port = parseInt(next, 10);
            break;
          case '-e':
          case '-env':
          case '--env':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.env = String(next);
            break;
          case '-c':
          case '-cluster':
          case '--cluster':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.cluster = parseInt(next, 10);
            break;
          case '-d':
          case '-delay':
          case '--delay':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.delay = parseInt(next, 10);
            break;
          case '-s':
          case '-setenv':
          case '--setenv':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            envs = (String(next)).split('=');
            if (/^[1-9][0-9\.]*$/.test(envs[1])) {
              envs[1] = parseFloat(envs[1], 10);
            }
            NC.OPTIONS.setenv[envs[0]] = envs[1];
            break;
          case '-x':
          case '-exec':
          case '--exec':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.exec = path.join(NC.ROOTDIR, next);
            break;
          case '-l':
          case '-log':
          case '--log':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.log = path.join(NC.ROOTDIR, next);
            break;
          case '-1':
          case '-stdout':
          case '--stdout':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.stdout = path.join(NC.ROOTDIR, next);
            break;
          case '-2':
          case '-stderr':
          case '--stderr':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.stderr = path.join(NC.ROOTDIR, next);
            break;
          case '-a':
          case '-assets':
          case '--assets':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.assets = path.join(NC.ROOTDIR, next);
            break;
          case '-o':
          case '-output':
          case '--output':
            if (typeof (next = ARGS.shift()) === 'undefined' || '-' === next.substr(0, 1)) {
              throw new Error("option '" + arg + "' requires parameter");
            }
            NC.OPTIONS.output = path.join(NC.ROOTDIR, next);
            break;
          case '-M':
          case '-minify':
          case '--minify':
            NC.OPTIONS.minify = true;
            break;
          case '-D':
          case '-daemon':
          case '--daemon':
            NC.OPTIONS.daemon = true;
            break;
          case '-W':
          case '-watch':
          case '--watch':
            NC.OPTIONS.watch = true;
            break;
          case '-N':
          case '-nocolor':
          case '--nocolor':
            NC.OPTIONS.nocolor = true;
            break;
          case '-v':
          case '-version':
          case '--version':
            NC.ACTIONS.version = true;
            break;
          case '-h':
          case '-help':
          case '--help':
            NC.ACTIONS.help = true;
            break;
          case '-debug':
          case '--debug':
            NC.ACTIONS.debug = true;
            break;
          default:
            throw new Error("unrecognized option: " + arg);
        }
      }
    }
    if (NC.OPTIONS.exec && '/' !== NC.OPTIONS.exec.substr(0, 1)) {
      NC.OPTIONS.exec = path.join(NC.ROOTDIR, NC.OPTIONS.exec);
    }
    _ref1 = ['log', 'stdout', 'stderr', 'assets', 'output'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      key = _ref1[_i];
      if (NC.OPTIONS[key] && '/' !== NC.OPTIONS[key].substr(0, 1)) {
        NC.OPTIONS[key] = path.join(NC.ROOTDIR, NC.OPTIONS[key]);
      }
      if ('/' === NC.OPTIONS[key].substr(-1)) {
        NC.OPTIONS[key] = NC.OPTIONS[key].substr(0, NC.OPTIONS[key].length - 1);
      }
    }
    if (!(NC.OPTIONS.setenv instanceof Object) && NC.OPTIONS.setenv.toString() !== '[object Object]') {
      envs = NC.OPTIONS.setenv.split('=');
      NC.OPTIONS.setenv = {};
      NC.OPTIONS.setenv[envs[0]] = envs[1];
    }
    if (isNaN(NC.OPTIONS.port)) {
      throw new Error("option '-p, port' parameter should number");
    }
    if (1 > NC.OPTIONS.env.length) {
      throw new Error("option '-e, env' parameter should string");
    }
    if (isNaN(NC.OPTIONS.cluster)) {
      throw new Error("option '-c, cluster' parameter should number");
    }
    if (isNaN(NC.OPTIONS.delay)) {
      throw new Error("option '-d, delay' parameter should number");
    }
    if (NC.OPTIONS.exec) {
      if (!fs.existsSync(NC.OPTIONS.exec || !(fs.statSync(NC.OPTIONS.exec)).isFile())) {
        throw new Error("option '-x, exec' parameter should file");
      }
    }
    if (NC.OPTIONS.log) {
      if (!fs.existsSync(path.dirname(NC.OPTIONS.log))) {
        mkdirp.sync(path.dirname(NC.OPTIONS.log));
      }
      if (!fs.existsSync(NC.OPTIONS.log)) {
        fs.writeFileSync(NC.OPTIONS.log, '');
      }
      if (!(fs.statSync(NC.OPTIONS.log)).isFile()) {
        throw new Error("option '-l, log' parameter should file");
      }
      NC.OPTIONS.stdout = NC.OPTIONS.stderr = NC.OPTIONS.log;
    }
    if (NC.OPTIONS.stdout) {
      if (!fs.existsSync(path.dirname(NC.OPTIONS.stdout))) {
        fs.mkdirSync(path.dirname(NC.OPTIONS.stdout));
      }
      if (!fs.existsSync(NC.OPTIONS.stdout)) {
        fs.writeFileSync(NC.OPTIONS.stdout, '');
      }
      if (!(fs.statSync(NC.OPTIONS.stdout)).isFile()) {
        throw new Error("option '-1, stdout' parameter should file");
      }
      STDOUT = fs.createWriteStream(NC.OPTIONS.stdout, {
        flags: 'a'
      });
    }
    if (NC.OPTIONS.stderr) {
      if (!fs.existsSync(path.dirname(NC.OPTIONS.stderr))) {
        fs.mkdirSync(path.dirname(NC.OPTIONS.stderr));
      }
      if (!fs.existsSync(NC.OPTIONS.stderr)) {
        fs.writeFileSync(NC.OPTIONS.stderr, '');
      }
      if (!(fs.statSync(NC.OPTIONS.stderr)).isFile()) {
        throw new Error("option '-2, stderr' parameter should file");
      }
      STDERR = fs.createWriteStream(NC.OPTIONS.stderr, {
        flags: 'a'
      });
    }
    if (NC.OPTIONS.assets) {
      if (!fs.existsSync(NC.OPTIONS.assets || !(fs.statSync(NC.OPTIONS.assets)).isDirectory())) {
        throw new Error("option '-a, assets' parameter should directory");
      }
      if (!NC.OPTIONS.output) {
        throw new Error("--assets requires --output");
      }
    }
    if (NC.OPTIONS.output) {
      if (!fs.existsSync(NC.OPTIONS.output || !(fs.statSync(NC.OPTIONS.output)).isDirectory())) {
        throw new Error("option '-o, output' parameter should directory");
      }
      if (!NC.OPTIONS.assets) {
        throw new Error("--output requires --assets");
      }
    }
  } catch (_error) {
    e = _error;
    console.error("\x1b[31mArgumentError: " + e.message + "\x1b[0m");
    return process.exit(1);
  } finally {
    process.env.PORT = NC.OPTIONS.port;
    process.env.NODE_ENV = NC.OPTIONS.env;
  }
})();

(function() {
  if (NC.ACTIONS.version || NC.ACTIONS.help) {
    console.log("nodectl version: " + NODECTL.name + "/" + NODECTL.version);
    if (NC.ACTIONS.help) {
      console.log("Usage: " + NODECTL.name + " [action] [options] <script>\n\nAction:\n  start   : start <script> as a node.js app\n  stop    : stop the <script>\n  restart : restart the <script>\n  status  : check the <program> running or not\n\nOptions:\n  -p, --port    : set process.env.PORT        " + process.env.PORT + "\n  -e, --env     : set process.env.NODE_ENV    " + process.env.NODE_ENV + "\n  -c, --cluster : number of concurrents       " + NC.OPTIONS.cluster + "\n  -d, --delay   : delay time for refork       " + NC.OPTIONS.delay + "\n  -s, --setenv  : set custom env (k=v)        " + ((util.inspect(NC.OPTIONS.setenv)).replace(/\n/g, '').replace(/\s\s*/g, ' ')) + "\n  -x, --exec    : exec job script             " + NC.OPTIONS.exec + "\n  -l, --log     : stdout+stderr log file      " + NC.OPTIONS.log + "\n  -1, --stdout  : stdout log file             " + NC.OPTIONS.stdout + "\n  -2, --stderr  : stderr log file             " + NC.OPTIONS.stderr + "\n  -a, --assets  : dir for assets              " + NC.OPTIONS.assets + "\n  -o, --output  : dir for assets output       " + NC.OPTIONS.output + "\n  -M, --minify  : minify compiled assets      " + NC.OPTIONS.minify + "\n  -D, --daemon  : daemonize process           " + NC.OPTIONS.daemon + "\n  -W, --watch   : restart app on code change  " + NC.OPTIONS.watch + "\n  -N, --nocolor : disable custom console      " + NC.OPTIONS.nocolor + "\n  -v, --version : show version and exit\n  -h, --help    : show this message and exit\n  --debug       : show debug information\n");
    }
    return process.exit(0);
  }
})();

(function() {
  var e;
  try {
    if (!NC.PROJECT.name) {
      throw new Error("application `name` unknown");
    }
    if (!NC.PROJECT.version) {
      throw new Error("application `version` unknown");
    }
    if (!NC.PROJECT.main) {
      throw new Error("application `main` script unknown");
    }
  } catch (_error) {
    e = _error;
    console.error("\x1b[31mProjectError: " + e.message + "\x1b[0m");
    console.error("\x1b[31mInformation must be described by package.json or .nodectl.json\x1b[0m");
    return process.exit(1);
  }
})();

(function() {
  var colorized, f, _i, _len, _ref1, _results;
  console.debug = function() {
    var arg, head, i, msg, _i, _j, _len, _len1, _ref1;
    if (NC.ACTIONS.debug) {
      msg = '\x1b[37m';
      msg += head = moment().format('HH:mm:ss') + ' debug';
      _ref1 = Array(20 - head.length);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        i = _ref1[_i];
        msg += ' ';
      }
      msg += '| ';
      for (i = _j = 0, _len1 = arguments.length; _j < _len1; i = ++_j) {
        arg = arguments[i];
        msg += typeof arg === 'string' ? arg : util.inspect(arg);
        if (arguments.length > i + 1) {
          msg += ' ';
        }
      }
      return util.print("" + msg + "\x1b[0m\n");
    }
  };
  if (!NC.OPTIONS.nocolor) {
    colorized = {};
    _ref1 = ['log', 'info', 'warn', 'error'];
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      f = _ref1[_i];
      _results.push((function(f) {
        colorized[f] = console[f];
        return console[f] = function() {
          var head, i, msg, _j, _len1, _ref2;
          msg = '';
          if (process.env.NODECTL === 'master') {
            msg += '\x1b[32m';
          } else if (/worker/.test(process.env.NODECTL)) {
            msg += '\x1b[33m';
          } else if (process.env.NODECTL === 'exec') {
            msg += '\x1b[34m';
          } else {
            msg += '\x1b[35m';
          }
          msg += head = moment().format('HH:mm:ss') + ' ' + process.env.NODECTL;
          _ref2 = Array(20 - head.length);
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            i = _ref2[_j];
            msg += ' ';
          }
          msg += '| ';
          msg += (function() {
            switch (f) {
              case 'log':
                return '\x1b[0m';
              case 'info':
                return '\x1b[34m';
              case 'warn':
                return '\x1b[33m';
              case 'error':
                return '\x1b[31m';
            }
          })();
          util.print(msg);
          colorized[f].apply(this, arguments);
          return util.print('\x1b[0m');
        };
      })(f));
    }
    return _results;
  }
})();

(function() {
  var _stderr, _stdout;
  _stdout = process.stdout.write;
  _stderr = process.stdout.write;
  process.stdout.write = function() {
    _stdout.apply(this, arguments);
    return STDOUT.write(arguments[0].replace(/\x1b.*?m/g, ''));
  };
  return process.stderr.write = function() {
    _stderr.apply(this, arguments);
    return STDERR.write(arguments[0].replace(/\x1b.*?m/g, ''));
  };
})();

(function() {
  process.stdout.pipe(STDOUT);
  process.stderr.pipe(STDERR);
  if (cluster.isMaster) {
    process.on('SIGINT', function() {
      util.print('\n');
      console.debug('Master trap SIGINT');
      NC.DELETES();
      return process.exit(1);
    });
    process.on('nodectl:restart', function() {
      var i, wid, _i, _len, _ref1, _results;
      console.debug("Restart all workers (delay: " + NC.OPTIONS.delay + " ms)");
      console.info("" + NC.PROCESS.id + " restart.");
      _ref1 = NC.PROCESS.wid;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        wid = _ref1[i];
        _results.push((function(wid, i) {
          console.debug("Send SIGINT to #" + wid);
          return setTimeout(function() {
            var e;
            try {
              return process.kill(wid, 'SIGINT');
            } catch (_error) {
              e = _error;
              return console.error("ProcessError: " + e.message);
            }
          }, NC.OPTIONS.delay * i);
        })(wid, i));
      }
      return _results;
    });
    return process.on('nodectl:rebuild', function(src, dst) {
      var code, e, len, startTime, tmp;
      try {
        console.debug("Build assets < " + src);
        console.debug("Build assets > " + dst);
        startTime = new Date;
        if (!fs.exists(path.dirname(dst))) {
          mkdirp.sync(path.dirname(dst));
        }
        code = fs.readFileSync(src, 'utf-8');
        code = (function() {
          switch (path.extname(src)) {
            case '.coffee':
              return coffee.compile(code);
            case '.styl':
              return stylus(code).set('paths', [path.join(NC.ROOTDIR, 'node_modules'), path.dirname(src)]).render();
            case '.jade':
              return jade.compile(code)();
            default:
              return code;
          }
        })();
        if (NC.OPTIONS.minify) {
          len = code.length;
          switch (path.extname(dst)) {
            case '.js':
              tmp = path.join('/tmp', new Date().toString());
              fs.writeFileSync(tmp, code);
              code = uglify.minify(tmp).code;
              fs.unlinkSync(tmp);
              break;
            case '.css':
              code = sqwish.minify(code);
              break;
            case '.html':
              code = markup.minify(code);
          }
          console.debug("Minified " + (parseInt(code.length / len * 1000) / 10) + " %");
        }
        console.debug("Elapsed time " + (new Date - startTime) + " ms");
        fs.writeFileSync(dst, code, 'utf-8');
        console.log("Build assets (" + (path.basename(src)) + " > " + (path.basename(dst)) + ")");
        return true;
      } catch (_error) {
        e = _error;
        console.error("Build assets failure. (" + src + ")");
        console.error(e.message);
        return false;
      }
    });
  }
})();

(function() {
  if (NC.ACTIONS.status) {
    if (fs.existsSync(NC.PROJECT.running)) {
      util.print("" + NC.PROJECT.name + " running.\n");
    } else {
      util.print("" + NC.PROJECT.name + " not running.\n");
    }
    return process.exit(0);
  }
})();

(function() {
  if (NC.ACTIONS.stop) {
    if (fs.existsSync(NC.PROJECT.running)) {
      process.kill(NC.PROCESS.pid, 'SIGINT');
    } else {
      console.warn("" + NC.PROCESS.id + " already stopped.");
    }
    return process.exit(0);
  }
})();

(function() {
  if (NC.ACTIONS.restart) {
    return process.emit('nodectl:restart');
  }
})();

(function() {
  var args, bin, child, dir, e, k, seekdir, timeout, v, _fn, _fn1, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
  if (NC.ACTIONS.start) {
    if (cluster.isMaster) {
      if (fs.existsSync(NC.PROJECT.running)) {
        console.warn("" + NC.PROCESS.id + " already runninng");
        process.exit(1);
      }
      _ref1 = NC.ACTIONS;
      for (k in _ref1) {
        v = _ref1[k];
        console.debug('act', k, ':', v);
      }
      _ref2 = NC.OPTIONS;
      for (k in _ref2) {
        v = _ref2[k];
        console.debug('opt', k, ':', v);
      }
      console.info("" + NC.PROCESS.id + " starting.");
      NC.PROCESS.pid = process.pid;
      cluster.on('online', function(worker) {
        return console.log("Worker online #" + worker.process.pid);
      });
      cluster.on('listening', function(worker) {
        return console.info("Worker listening #" + worker.process.pid);
      });
      cluster.on('exit', function(worker) {
        var i, wid, _i, _len, _ref3, _worker;
        console.warn("Worker exit #" + worker.process.pid + " (" + (worker.suicide ? 'suicide' : 'no suicide') + ")");
        _ref3 = NC.PROCESS.wid;
        for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
          wid = _ref3[i];
          if (wid === worker.process.pid) {
            NC.PROCESS.wid.splice(i, 1);
            _worker = cluster.fork({
              NODECTL: worker.type
            });
            _worker.type = worker.type;
            NC.PROCESS.wid.push(_worker.process.pid);
          }
        }
        return NC.EXPORTS();
      });
      if (NC.OPTIONS.daemon) {
        if (!process.env.__daemon) {
          console.log("Master daemonize");
          args = [].concat(process.argv);
          args.shift();
          args.shift();
          process.env.__daemon = true;
          child = spawn(process.mainModule.filename, args, {
            stdio: 'ignore',
            env: process.env,
            cwd: process.cwd(),
            detached: true
          });
          child.unref();
          process.exit(0);
        }
        NC.PROCESS.pid = process.pid;
      }
      NC.EXPORTS();
      if (NC.OPTIONS.exec) {
        bin = (function() {
          switch (path.extname(NC.OPTIONS.exec)) {
            case '.coffee':
              return path.join(ROOTCTL, 'node_modules', 'coffee-script', 'bin', 'coffee');
            default:
              return 'node';
          }
        })();
        try {
          child = spawn(bin, [NC.OPTIONS.exec], {
            env: process.env,
            cwd: process.cwd(),
            detached: true
          });
          child.stdout.on('data', function(data) {
            var head, i, msg, _i, _len, _ref3;
            msg = '\x1b[34m';
            msg += head = moment().format('HH:mm:ss') + ' exec';
            _ref3 = Array(20 - head.length);
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              i = _ref3[_i];
              msg += ' ';
            }
            msg += '| ';
            return util.print("\x1b[32m" + msg + "\x1b[0m" + data);
          });
          child.stderr.on('data', function(data) {
            var head, i, msg, _i, _len, _ref3;
            msg = '\x1b[34m';
            msg += head = moment().format('HH:mm:ss') + ' exec';
            _ref3 = Array(20 - head.length);
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              i = _ref3[_i];
              msg += ' ';
            }
            msg += '| ';
            return util.print("" + msg + "\x1b[0m" + data);
          });
          console.log("Master spawn #" + child.pid);
          NC.PROCESS.xid = child.pid;
        } catch (_error) {
          e = _error;
          console.error(e);
        } finally {
          NC.EXPORTS();
        }
      }
      seekdir = function(dir) {
        var abs, rel, res, _i, _len, _ref3;
        res = [];
        if ((fs.statSync(dir)).isFile()) {
          return res;
        }
        _ref3 = fs.readdirSync(dir);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          rel = _ref3[_i];
          abs = path.join(dir, rel);
          if (rel !== 'node_modules' && (rel.substr(0, 1)) !== '.') {
            if ((fs.statSync(abs)).isDirectory()) {
              res.push(abs);
              res = res.concat(arguments.callee(abs));
            }
          }
        }
        return res;
      };
      if (NC.OPTIONS.watch) {
        _ref3 = [NC.ROOTDIR].concat(seekdir(NC.ROOTDIR));
        _fn = function(dir) {
          var _this = this;
          if ((new RegExp(NC.OPTIONS.assets)).test(dir)) {
            return null;
          }
          if ((new RegExp(NC.OPTIONS.output)).test(dir)) {
            return null;
          }
          console.log('Master watch', '<', dir);
          return fs.watch(dir, function(act, rel) {
            var timeout;
            console.debug("fs watch triggerd (" + act + ", " + rel + ")");
            if (/\.(js|coffee|json)$/.test(rel)) {
              clearTimeout(timeout);
              return timeout = setTimeout(function() {
                var abs;
                abs = path.join(dir, rel);
                if (act === 'change' || fs.existsSync(abs)) {
                  console.log("Code changed (" + rel + ")");
                  return process.emit('nodectl:restart', act, abs, null);
                }
              }, NC.OPTIONS.delay);
            }
          });
        };
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          dir = _ref3[_i];
          timeout = null;
          _fn(dir);
        }
      }
      if (NC.OPTIONS.assets && NC.OPTIONS.output) {
        _ref4 = [NC.OPTIONS.assets].concat(seekdir(NC.OPTIONS.assets));
        _fn1 = function(dir) {
          var out,
            _this = this;
          out = dir.replace(NC.OPTIONS.assets, NC.OPTIONS.output);
          console.log('Master watch assets', '<', dir);
          return fs.watch(dir, function(act, rel) {
            console.debug("fs watch triggerd (" + act + ", " + rel + ")");
            if (/\.(js|coffee|css|styl|html|jade)$/.test(rel)) {
              clearTimeout(timeout);
              return timeout = setTimeout(function() {
                var abs, dst;
                abs = path.join(dir, rel);
                dst = (function() {
                  switch (path.extname(rel)) {
                    case '.coffee':
                      return path.join(out, rel.replace(/\.coffee$/, '.js'));
                    case '.styl':
                      return path.join(out, rel.replace(/\.styl$/, '.css'));
                    case '.jade':
                      return path.join(out, rel.replace(/\.jade$/, '.html'));
                    default:
                      return path.join(out, rel);
                  }
                })();
                if (fs.existsSync(abs)) {
                  return process.emit('nodectl:rebuild', abs, dst);
                } else {
                  return fs.unlinkSync(dst);
                }
              }, NC.OPTIONS.delay);
            }
          });
        };
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          dir = _ref4[_j];
          timeout = null;
          _fn1(dir);
        }
      }
      return (function() {
        var i, worker, _k, _ref5;
        for (i = _k = 0, _ref5 = NC.OPTIONS.cluster; 0 <= _ref5 ? _k < _ref5 : _k > _ref5; i = 0 <= _ref5 ? ++_k : --_k) {
          worker = cluster.fork({
            NODECTL: "worker." + (i + 1)
          });
          worker.type = "worker." + (i + 1);
          NC.PROCESS.wid.push(worker.process.pid);
        }
        return NC.EXPORTS();
      })();
    } else {
      process.on('SIGINT', function() {
        console.debug('Worker trap SIGINT');
        process.suicide = true;
        return process.exit(0);
      });
      return require(path.join(NC.ROOTDIR, NC.PROJECT.main));
    }
  }
})();
