// Generated by CoffeeScript 1.6.3
var PROJECT, action, actions, arg, args, assets, child, cluster, coffee, crypto, defaults, dir, e, escapeRegExp, exec, findsByExtPattern, fs, i, isCode, isDir, isFile, j, jade, logger, markup, method, mkdirp, noseinfo, options, origin, output, packages, path, pid, pidfile, pidfiles, print, reloadAllChilds, shasum, spawn, sqwish, stream, stylus, uglify, up, watch, widfile, workers, _fn, _fn1, _fn2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

coffee = require('coffee-script');

stylus = require('stylus');

jade = require('jade');

fs = require('fs');

path = require('path');

print = require('util').print;

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

cluster = require('cluster');

crypto = require('crypto');

shasum = function(source) {
  return crypto.createHash('sha1').update(source).digest('hex');
};

mkdirp = require('mkdirp');

uglify = require('uglify-js');

sqwish = require('sqwish');

markup = require('html-minifier');

PROJECT = path.resolve();

_ref1 = (path.resolve()).split('/');
for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
  dir = _ref1[i];
  up = '';
  _ref2 = Array(i);
  for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
    j = _ref2[_j];
    up += '../';
  }
  if (fs.existsSync(path.resolve(up, 'package.json'))) {
    packages = require(path.resolve(up, 'package.json'));
    PROJECT = path.resolve(up);
    break;
  }
}

defaults = (function() {
  switch (false) {
    case !fs.existsSync(path.join(PROJECT, '.nodectl.json')):
      return require(path.join(PROJECT, '.nodectl.json'));
    default:
      return {};
  }
})();

noseinfo = require('../package.json');

packages || (packages = {
  name: 'unknown',
  version: 'unknown'
});

pidfiles = "../tmp/" + ".pid";

args = [].concat(process.argv);

action = 'start';

actions = {
  main: defaults.main || packages.main || '',
  stop: false,
  start: false,
  clear: false,
  reload: false,
  status: false,
  help: false,
  version: false
};

options = {
  port: defaults.port || packages.port || 3000,
  env: defaults.env || packages.env || 'development',
  cluster: defaults.cluster || packages.cluster || require('os').cpus().length,
  delay: defaults.cluster || packages.cluster || 250,
  logpath: defaults.logpath || packages.logpath || null,
  pidpath: defaults.pidpath || packages.pidpath || path.join(path.dirname(process.mainModule.filename), '..', 'tmp'),
  execmaster: defaults.execmaster || packages.execmaster || false,
  nocolor: defaults.nocolor || packages.nocolor || false,
  daemon: defaults.daemon || packages.daemon || false,
  watch: defaults.watch || packages.watch || false,
  assets: defaults.assets || packages.assets || null,
  output: defaults.output || packages.output || null,
  minify: defaults.minify || packages.minify || false,
  verbose: defaults.verbose || packages.verbose || false
};

try {
  args = [].concat(process.argv);
  args.shift();
  args.shift();
  while (arg = args.shift()) {
    switch (arg) {
      case 'stop':
        action = 'stop';
        actions.start = false;
        actions.stop = true;
        break;
      case 'start':
        action = 'start';
        actions.start = true;
        actions.stop = false;
        break;
      case 'restart':
        action = 'restart';
        actions.start = true;
        actions.stop = true;
        break;
      case 'force-clear':
      case 'force_clear':
        action = 'force-clear';
        actions.start = false;
        actions.stop = false;
        actions.clear = true;
        break;
      case 'reload':
        action = 'reload';
        actions.reload = true;
        break;
      case 'status':
        action = 'status';
        actions.status = true;
        break;
      case '-p':
      case '-port':
      case '--port':
        options.port = parseInt(args.shift(), 10);
        if (isNaN(options.port)) {
          throw new Error("" + arg + " [INT], port number");
        }
        break;
      case '-e':
      case '-env':
      case '--env':
        options.env = args.shift();
        break;
      case '-c':
      case '-cluster':
      case '--cluster':
        options.cluster = parseInt(args.shift(), 10);
        if (isNaN(options.cluster)) {
          throw new Error("" + arg + " [INT], number of fork children");
        }
        break;
      case '-D':
      case '-delay':
      case '--delay':
        options.delay = parseInt(args.shift(), 10);
        if (isNaN(options.delay)) {
          throw new Error("" + arg + " [INT], reload delay time (ms)");
        }
        break;
      case '-l':
      case '-logpath':
      case '--logpath':
        options.logpath = args.shift();
        break;
      case '-P':
      case '-pidpath':
      case '--pidpath':
        options.pidpath = args.shift();
        break;
      case '-x':
      case '-execmaster':
      case '--execmaster':
        options.execmaster = args.shift();
        break;
      case '-n':
      case '-nocolor':
      case '--nocolor':
        options.nocolor = true;
        break;
      case '-d':
      case '-daemon':
      case '--daemon':
        options.daemon = true;
        break;
      case '-w':
      case '-watch':
      case '--watch':
        options.watch = true;
        break;
      case '-a':
      case '-assets':
      case '--assets':
        assets = path.resolve(args.shift());
        if (fs.existsSync(assets)) {
          options.assets = assets;
        }
        break;
      case '-o':
      case '-output':
      case '--output':
        output = path.resolve(args.shift());
        if (fs.existsSync(output)) {
          options.output = output;
        }
        break;
      case '-m':
      case '-minify':
      case '--minify':
        options.minify = true;
        break;
      case '-V':
      case '-verbose':
      case '--verbose':
        options.verbose = true;
        break;
      case '-v':
      case '-version':
      case '--version':
        actions.version = true;
        break;
      case '-h':
      case '-help':
      case '--help':
      case 'help':
        actions.help = true;
        break;
      default:
        actions.main = arg;
    }
  }
} catch (_error) {
  e = _error;
  console.error(e.message);
}

process.env.PORT = options.port;

process.env.NODE_ENV = options.env;

if (action === 'start') {
  actions.start = true;
}

if (!options.nocolor) {
  origin = {};
  _ref3 = ['log', 'info', 'warn', 'error'];
  _fn = function(method) {
    origin[method] = console[method];
    return console[method] = function() {
      print((function() {
        switch (method) {
          case 'log':
            return '\x1b[37m';
          case 'info':
            return '\x1b[34m';
          case 'warn':
            return '\x1b[33m';
          case 'error':
            return '\x1b[31m';
        }
      })());
      origin[method].apply(this, arguments);
      return print('\x1b[0m');
    };
  };
  for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
    method = _ref3[_k];
    _fn(method);
  }
}

if (actions.help) {
  console.log("" + noseinfo.name + " version " + noseinfo.version + "\n\nRepo:\n  https://github.com/geta6/nodectl\n\nTarget:\n  " + packages.name + " version " + packages.version + "\n\nUsage:\n  " + noseinfo.name + " [action] [options] <program>\n\nAction:\n  start        execute <program> (default action)\n  stop         stop daemonized <program>\n  restart      restart <program> with daemonize mode\n  force-clear  force clear pid\n  reload       apply edited javascript\n  status       check <program> running or not\n  help         show this message and exit\n\nOptions:\n  -p, --port [3000]        pass listening port with `process.env.PORT`\n  -e, --env [development]  pass environment with `process.env.NODE_ENV`\n  -c, --cluster []         concurrent process with cpu threads default\n  -d, --daemon             daemonize process\n  -w, --watch              watch code changes, auto reload programs\n  -D, --delay [250]        delay time for re-fork child workers\n  -n, --nocolor            stop colorize console\n  -P, --pidpath [(auto)]   directory for pid files\n  -l, --logpath []         directory for log files\n  -x, --execmaster []      execute script on master process\n  -a, --assets []          directory for assets watch and compile (js, coffee, css, styl, html, jade)\n  -o, --output []          directory for output js/css\n  -m, --minify             minify compiled assets\n  -V, --verbose            show verbose information on launch and compiled\n  -v, --version            show version and exit\n  -h, --help               show this message and exit");
  process.exit(1);
}

if (actions.version) {
  console.log("" + noseinfo.name + " version " + noseinfo.version);
  process.exit(1);
}

if (!fs.existsSync(options.pidpath)) {
  fs.mkdirSync(path.join(options.pidpath));
}

pidfile = path.join("" + options.pidpath, "" + packages.name + ".pid");

widfile = path.join("" + options.pidpath, "" + packages.name + ".wid");

if (options.logpath) {
  if (!fs.existsSync(options.logpath)) {
    fs.mkdirSync(path.join(options.logpath));
  }
}

stream = false;

if (options.logpath) {
  stream = {
    master: fs.createWriteStream(path.join("" + options.logpath, "master.log"), {
      flags: 'a'
    }),
    masterErr: fs.createWriteStream(path.join("" + options.logpath, "master.error.log"), {
      flags: 'a'
    }),
    worker: fs.createWriteStream(path.join("" + options.logpath, "worker.log"), {
      flags: 'a'
    }),
    workerErr: fs.createWriteStream(path.join("" + options.logpath, "worker.error.log"), {
      flags: 'a'
    })
  };
} else {
  options.logpath = null;
}

logger = function(control, isMaster) {
  var stderr, stdout;
  if (isMaster == null) {
    isMaster = false;
  }
  if (stream) {
    stdout = control.stdout.write;
    stderr = control.stderr.write;
    if (isMaster) {
      control.stdout.write = function() {
        stdout.apply(this, arguments);
        return stream.master.write(arguments[0].replace(/\x1b.*?m/g, ''));
      };
      return control.stderr.write = function() {
        stderr.apply(this, arguments);
        return stream.masterErr.write(arguments[0].replace(/\x1b.*?m/g, ''));
      };
    } else {
      control.stdout.write = function() {
        stdout.apply(this, arguments);
        return stream.worker.write(arguments[0].replace(/\x1b.*?m/g, ''));
      };
      return control.stderr.write = function() {
        stderr.apply(this, arguments);
        return stream.workerErr.write(arguments[0].replace(/\x1b.*?m/g, ''));
      };
    }
  }
};

reloadAllChilds = function(delay) {
  var wid, _l, _len3, _ref4, _results;
  if (delay == null) {
    delay = 0;
  }
  console.info('>>> Reload all childs.');
  if (fs.existsSync(widfile)) {
    _ref4 = (fs.readFileSync(widfile, 'utf-8')).split(' ');
    _results = [];
    for (i = _l = 0, _len3 = _ref4.length; _l < _len3; i = ++_l) {
      wid = _ref4[i];
      _results.push((function(wid, i) {
        return setTimeout(function() {
          try {
            return process.kill(wid, 'SIGINT');
          } catch (_error) {
            e = _error;
            return console.error(e.message);
          }
        }, delay * i);
      })(wid, i));
    }
    return _results;
  } else {
    return console.error('widfile missing.');
  }
};

if (actions.stop) {
  if (cluster.isMaster) {
    if (fs.existsSync(pidfile)) {
      pid = parseInt(fs.readFileSync(pidfile, 'utf-8'), 10);
      try {
        process.kill(pid, 'SIGINT');
        console.log("" + packages.name + " stopped.");
        if (fs.existsSync(pidfile)) {
          fs.unlinkSync(pidfile);
        }
        if (fs.existsSync(widfile)) {
          fs.unlinkSync(widfile);
        }
      } catch (_error) {
        e = _error;
        console.error("kill " + pid + " failed: no such process.");
      }
    } else {
      console.error("" + packages.name + " not running, pidfile not exists.");
    }
  }
}

if (actions.clear) {
  console.warn("clear pidfile for " + packages.name + ".");
  if (fs.existsSync(pidfile)) {
    pid = parseInt(fs.readFileSync(pidfile, 'utf-8'), 10);
    if (fs.existsSync(pidfile)) {
      fs.unlinkSync(pidfile);
    }
    if (fs.existsSync(widfile)) {
      fs.unlinkSync(widfile);
    }
    try {
      process.kill(pid, 'SIGINT');
      console.log("" + packages.name + " stopped.");
    } catch (_error) {
      e = _error;
      console.error("kill " + pid + " failed: no such process.");
    }
  }
}

if (actions.reload) {
  reloadAllChilds(options.delay);
}

if (actions.status) {
  if (fs.existsSync(pidfile)) {
    console.log("" + packages.name + " running.");
  } else {
    console.log("" + packages.name + " not running.");
  }
}

if (actions.start) {
  if (!fs.existsSync(actions.main)) {
    console.error("`" + actions.main + "` is not action, or not exists.");
    process.exit(1);
  }
  if (cluster.isMaster) {
    if (fs.existsSync(pidfile)) {
      console.error("" + packages.name + " already running.");
      process.exit(1);
    }
    console.log("" + packages.name + " version " + packages.version);
    if (options.verbose) {
      console.log("");
      if (fs.existsSync(path.join(PROJECT, '.nodectl.json'))) {
        console.log(">>> .nodectl.json exists");
      } else {
        console.log(">>> .nodectl.json NOT exists");
      }
      console.log("");
      console.log(">>> Param:");
      console.log(">>>   listening port  ... " + options.port);
      console.log(">>>   environment     ... " + options.env);
      console.log(">>>   concurrent      ... " + options.cluster);
      console.log(">>>   daemonize       ... " + options.daemon);
      console.log(">>>   watchmode       ... " + options.watch);
      console.log(">>>   colorlize       ... " + (!options.nocolor));
      console.log(">>>   releaseDelay    ... " + options.delay);
      console.log(">>>   execmaster      ... " + options.execmaster);
      console.log(">>>   assets          ... " + options.assets);
      console.log(">>>   output          ... " + options.output);
      console.log(">>>   minify          ... " + options.minify);
      console.log(">>>   logpath         ... " + options.logpath);
      console.log(">>>   pidpath         ... " + options.pidpath);
      console.log(">>>   pidfile         ... " + pidfile);
      console.log("");
    }
    workers = [];
    cluster.on('fork', function(worker) {
      return console.log("> Process forked #" + worker.process.pid);
    });
    cluster.on('listening', function(worker) {
      return console.info(">> State listening #" + worker.process.pid);
    });
    cluster.on('exit', function(worker) {
      var wid, _l, _len3;
      console.error("<< State exit #" + worker.process.pid);
      console.info("> Refork process");
      for (i = _l = 0, _len3 = workers.length; _l < _len3; i = ++_l) {
        wid = workers[i];
        if (wid === worker.process.pid) {
          workers.splice(i, 1);
          workers.push(cluster.fork().process.pid);
        }
      }
      return fs.writeFileSync(widfile, workers.join(' '));
    });
    for (i = _l = 0, _ref4 = options.cluster; 0 <= _ref4 ? _l < _ref4 : _l > _ref4; i = 0 <= _ref4 ? ++_l : --_l) {
      workers.push(cluster.fork().process.pid);
    }
    fs.writeFileSync(widfile, workers.join(' '));
    isFile = function(file) {
      return fs.statSync(file).isFile();
    };
    isDir = function(dir) {
      return fs.statSync(dir).isDirectory();
    };
    isCode = function(file) {
      return /\.(coffee|js|json)$/.test(path.extname(file));
    };
    if (options.execmaster) {
      options.execmaster = path.join(process.cwd(), options.execmaster);
      if (!fs.existsSync(options.execmaster)) {
        console.error("-x --execmaster '" + options.execmaster + "' not exists");
        process.exit(1);
      }
      if (!isFile(options.execmaster)) {
        console.error("-x --execmaster '" + options.execmaster + "' not file");
        process.exit(1);
      }
      if (!(isCode(options.execmaster))) {
        console.error("-x --execmaster '" + options.execmaster + "' not script");
        process.exit(1);
      }
    }
    if (options.daemon) {
      if (!process.env.__daemon) {
        if (options.verbose) {
          console.log(">>> Daemonize process");
        }
        args = [].concat(process.argv);
        args.shift();
        args.shift();
        process.env.__daemon = true;
        child = spawn(process.mainModule.filename, args, {
          stdio: 'ignore',
          env: process.env,
          cwd: process.cwd(),
          detached: true
        });
        child.unref();
        process.exit();
      }
    }
    findsByExtPattern = function(dir, pattern) {
      var dst, files, src, _len3, _m, _ref5;
      files = [];
      _ref5 = fs.readdirSync(dir);
      for (_m = 0, _len3 = _ref5.length; _m < _len3; _m++) {
        src = _ref5[_m];
        dst = path.join(dir, src);
        if ((dst !== 'node_modules') && (isDir(dst))) {
          files = files.concat(findsByExtPattern(dst, pattern));
        } else if (!/^\./.test(src)) {
          if (pattern.test(dst)) {
            files.push(path.resolve(dst));
          }
        }
      }
      return files;
    };
    escapeRegExp = function(string) {
      return string.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
    };
    if (options.watch) {
      _ref5 = findsByExtPattern('.', /\.(js|coffee|json)$/);
      _fn1 = function(watch) {
        var matchAssets, matchOutput, regexAssets, regexOutput;
        if (isFile(watch)) {
          matchAssets = false;
          matchOutput = false;
          if (options.assets) {
            regexAssets = new RegExp("^" + (escapeRegExp(path.resolve(options.assets))) + ".*");
            matchAssets = regexAssets.test(watch);
          }
          if (options.output) {
            regexOutput = new RegExp("^" + (escapeRegExp(path.resolve(options.output))) + ".*");
            matchOutput = regexOutput.test(watch);
          }
          if (!matchAssets && !matchOutput) {
            try {
              if (options.verbose) {
                console.log(">>> [Script] Now wathing '" + watch + "'");
              }
              return fs.watch(watch, function() {
                if (options.verbose) {
                  console.log(">>> [Script] Updated '" + watch + "'");
                }
                console.info(">> Script updated.");
                return reloadAllChilds(options.delay);
              });
            } catch (_error) {
              e = _error;
              return console.error("Watch script " + watch + " failed");
            }
          }
        }
      };
      for (_m = 0, _len3 = _ref5.length; _m < _len3; _m++) {
        watch = _ref5[_m];
        _fn1(watch);
      }
    }
    if (options.assets && options.output) {
      _ref6 = findsByExtPattern(options.assets, /\.(js|coffee|styl)$/);
      _fn2 = function(watch) {
        if (isFile(watch)) {
          try {
            if (options.verbose) {
              console.log(">>> [Assets] Now wathing '" + watch + "'");
            }
            return fs.watch(watch, function() {
              var code, dest, startTime, temp;
              try {
                startTime = new Date();
                code = '';
                dest = path.resolve(path.join(options.output, watch.replace(path.resolve(options.assets), '')));
                if (!fs.exists(path.dirname(dest))) {
                  mkdirp.sync(path.dirname(dest));
                }
                if (/\.(js|coffee)$/.test(watch)) {
                  dest = path.join(path.dirname(dest), (path.basename(dest, path.extname(dest))) + '.js');
                  code = (function() {
                    switch (path.extname(watch)) {
                      case '.coffee':
                        return coffee.compile(fs.readFileSync(watch, 'utf-8'));
                      default:
                        return fs.readFileSync(watch, 'utf-8');
                    }
                  })();
                  if (options.minify) {
                    temp = path.join('/tmp', shasum((Date.now()).toString()));
                    fs.writeFileSync(temp, code);
                    code = uglify.minify(temp).code;
                    fs.unlinkSync(temp);
                  }
                }
                if (/\.(css|styl)$/.test(watch)) {
                  dest = path.resolve(path.join(path.dirname(dest), (path.basename(dest, path.extname(dest))) + '.css'));
                  code = (function() {
                    switch (path.extname(watch)) {
                      case '.styl':
                        return (stylus(fs.readFileSync(watch, 'utf-8'))).set('paths', [path.resolve('node_modules'), options.assets]).render();
                      default:
                        return fs.readFileSync(watch, 'utf-8');
                    }
                  })();
                  if (options.minify) {
                    code = sqwish.minify(code);
                  }
                }
                if (/\.(html|jade)$/.test(watch)) {
                  dest = path.resolve(path.join(path.dirname(dest), (path.basename(dest, path.extname(dest))) + '.html'));
                  code = (function() {
                    switch (path.extname(watch)) {
                      case '.jade':
                        return (jade.compile(fs.readFileSync(watch, 'utf-8')))();
                      default:
                        return fs.readFileSync(watch, 'utf-8');
                    }
                  })();
                  if (options.minify) {
                    code = markup.minify(code);
                  }
                }
                if (code) {
                  fs.writeFileSync(dest, code, 'utf-8');
                  if (options.verbose) {
                    console.log(">>> " + watch + " -> " + dest);
                    if (options.minify) {
                      console.log(">>> code minified.");
                    }
                  }
                  return console.info(">> " + (path.basename(dest)) + " compiled. (" + (new Date() - startTime) + "ms)");
                }
              } catch (_error) {
                e = _error;
                console.error(">> Failure to compile.");
                return console.error(e.message);
              }
            });
          } catch (_error) {
            e = _error;
            return console.error(">> Watch asset " + watch + " failed");
          }
        }
      };
      for (_n = 0, _len4 = _ref6.length; _n < _len4; _n++) {
        watch = _ref6[_n];
        _fn2(watch);
      }
    }
    console.log("");
    if (options.execmaster) {
      require(options.execmaster);
    }
    fs.writeFileSync(pidfile, process.pid);
    process.stdout.pipe(process.stdin);
    process.on('exit', function() {
      if (fs.existsSync(pidfile)) {
        fs.unlinkSync(pidfile);
      }
      if (fs.existsSync(widfile)) {
        return fs.unlinkSync(widfile);
      }
    });
    process.on('SIGINT', function() {
      return process.exit(0);
    });
    logger(process, true);
  } else {
    require(path.join(process.cwd(), actions.main));
    logger(process, false);
  }
}
